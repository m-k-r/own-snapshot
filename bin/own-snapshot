#!/bin/bash
#
# -----------------------------------------------------------------------------
#
# Author:	Marcel Keller (m-k-r)
# Usage:	uses config files to create and delete snapshots for btrfs, zfs, file, directory, mysql, pgsql and kvm
# License:	GPLv3 http://www.gnu.org/licenses/gpl-3.0
#
# ----------------------------- Global Variables ------------------------------

version=1.1
usage="usage: own-snapshot [parameter]

 -c	create initial config-directories, upgrade elements, create and change elements and jobs (not yet implemented)
 -e	name of the element without '.snap'at the end
 -i	impede new snapshots. used to handle snapshots or files created by other programms
 -f	the frequency as defined in the config file (hourly, daily, weekly)
 -l	either date-string (list) or complete label (single). mainly used by own-backup
 -o	output level: previous, commands, config, snapshots, full
 -v	show version of this script
 -h	this page

parameter used by ownbackup

 -m	mode (btrfs, zfs)
 -n	target for snapshot
 -p	port for ssh
 -q	path to credentials file for sql
 -r	source for snapshot
 -s	server
 -z	certificate file/gpg id"
dir_root=/usr/local/own-snapshot
dir_modules=${dir_root}/modules
dir_conf=/etc/own-snapshot
config_options_rsync="-a"
supported_mode="btrfs zfs directory file kvm lxd mysql pgsql ldap"
supported_element_version=1.2


# --------------------------------- Parameter ----------------------------------

if [[ "$#" == "0" ]]; then
	echo "${usage}" && exit 0
fi

while getopts ":c:e:if:l:m:n:o:p:q:r:s:z:vh" opt; do
	case ${opt} in
		c)	arg_config=$OPTARG
			;;
		e)	arg_element=$OPTARG
			;;
		i)	snap_new_impede=set
			;;
		f)	current_frequency=$OPTARG
			;;
		l)	snap_string=$OPTARG
			;;
		m)	mode=$OPTARG
			;;
		n)	snap_set=($OPTARG)
			;;
		o)	output=$OPTARG
			;;
		p)	config_port=($OPTARG)
			;;
		q)	config_credentials=$OPTARG
			;;
		r)	root_set=($OPTARG)
			;;
		s)	config_server=$OPTARG
			;;
		z)	config_certificate=$OPTARG
			;;
		v)	echo "${version}"
			exit 0
			;;
		h)	echo "${usage}"
			exit 0
			;;
		?)	echo "Invalid option: -$OPTARG" >&2
			exit 1
			;;
	esac
done

# -----------------------------------------------------------------------------

# backup ifs
IFSBAK=${IFS}

if [[ -n "${arg_config}" ]]; then
	backend=snapshot
	export dir_conf arg_config backend
	${dir_modules}/do-config
	exit 0
fi

## output-level:
##	previous:	checks if previous snapshot with the same name exists
##	commands:	show commands for snapshot & snapshot-deletion
##	progress:	from own-backup will be translated to previous
##	snapvars:	from own-backup will be translated to commands
##	config:		checks if the configuration is valid
##	snapshots:	commands + show the snapshotlists, -numbers
##	full:		all the above

# define outputlevel
if [[ -n "${output}" ]]; then
	if [[ "${output}" == "config" ]]; then
		check_config="set"

	elif [[ "${output}" == "previous" ]] || [[ "${output}" == "progress" ]]; then
		check_previous="set"

	elif [[ "${output}" == "commands" ]] || [[ "${output}" == "snapvars" ]]; then
		check_commands="set"
		add_snapshot="set"

	elif [[ "${output}" == "snapshots" ]]; then
		check_commands="set"
		check_snapshots="set"
		snap_new_impede=set

	elif [[ "${output}" == "full" ]]; then
		check_config="set"
		check_previous="set"
		check_commands="set"
		check_snapshots="set"; else

		echo "no supported output-level found: ${output}" && exit 1
	fi
fi

# define the function and basic parameters
if [[ -n "${arg_element}" ]]; then
	config_function="list"
	element=${dir_conf}/snapshot/${arg_element}.snap; else
	config_function="single"
	snap_limit=(1)
fi

if [[ "${config_function}" == "list" ]]; then
	# check if config is set
	if [[ "$check_config" == "set" ]]; then
		probe=$(find ${element} 2>&1)
		if [[ ! "${probe}" == "${element}" ]]; then
			echo "the config does not exist" && exit 1
		fi
	fi

	# parse the blocks
	block_config=$(awk '/^#config#$/ {flag=!flag; count+=1; next} flag && count < 2 {print}' ${element})
	block_table=$(awk '/^#table#$/ {flag=!flag; count+=1; next} flag && count < 2 {print}' ${element})
	# parse the blocks (into array) by newline, in case a source or target contains spaces
	IFS=$'\n'
	root_set=($(awk '/^#source#$/ {flag=!flag; count+=1; next} flag && count < 2 {print}' ${element}))
	snap_set=($(awk '/^#target#$/ {flag=!flag; count+=1; next} flag && count < 2 {print}' ${element}))
	IFS=${IFSBAK}

	# check element version
	element_version=$(awk -v condition1="version" '$1 == condition1 { print $3 }' <<< "${block_config}")
	if [[ ! "${element_version}" == "${supported_element_version}" ]]; then
		echo "the element has not the requiered version. please update the elements with own-snapshot -c upgrade" && exit 1
	fi
	config_server=$(awk -v condition1="server" '$1 == condition1 { print $3 }' <<< "${block_config}")
	config_port=$(awk -v condition1="server" '$1 == condition1 { print $4 }' <<< "${block_config}")
	mode=$(awk -v condition1="mode" '$1 == condition1 { print $3 }' <<< "${block_config}")
	snap_label=$(awk -v condition1="label" '$1 == condition1 { print $3 }' <<< "${block_config}")
	# snap_string can be given by argument so that all snapshots follow the same scheme
	if [[ -n "${snap_string}" ]]; then
		snap_date=${snap_string}; else
		snap_date=$(date +$(awk -v condition1="dateformat" '$1 == condition1 { print $3 }' <<< "${block_config}"))
	fi
	snap_identifier=$(awk -v condition1="identifier" '$1 == condition1 { print $3 }' <<< "${block_config}")
	snap_string_separator_1=$(awk -v condition1="separator" '$1 == condition1 { print $3 }' <<< "${block_config}")
	snap_string_separator_2=$(awk -v condition1="separator" '$1 == condition1 { print $4 }' <<< "${block_config}")
	probe=$(awk -v condition1="snap_flags" '$1 == condition1 { print $3 }' <<< "${block_config}")
	if [[ "${probe}" == "existing" ]]; then
		snap_new_impede=set;
	elif [[ "${probe}" == "archival" ]]; then
		snap_pre_rollback=$(awk -v condition1="snap_flags" '$1 == condition1 { print $4 }' <<< "${block_config}" | tr ":" " ")
	fi
	config_target=$(awk -v condition1="snap_location" '$1 == condition1 { print $3 }' <<< "${block_config}")
	config_credentials=$(awk -v condition1="credentials" '$1 == condition1 { print $3 }' <<< "${block_config}")
	config_certificate=$(awk -v condition1="encryption" '$1 == condition1 { print $3 }' <<< "${block_config}")
	config_compression=$(awk -v condition1="encryption" '$1 == condition1 { print $3, $4 }' <<< "${block_config}")
	config_user=$(awk -v condition1="user" '$1 == condition1 { print $3 }' <<< "${block_config}")

	# get snapshot table
	supported_frequencies=$(head -n 1 <<< "${block_table}")
	# get the retention number of snapshots for current frequency
	snap_nmbr=$(awk -v name="${current_frequency}" '{for (i=1;i<=NF;i++) if ($i==name) print i; exit}' <<< "${supported_frequencies}")
	if [[ ! -n "${snap_nmbr}" ]]; then
		echo "frequency: ${current_frequency} not found. supported are: ${supported_frequencies}" >&2 && exit 1
	fi
	snap_limit=($(tail -n +2 <<< "${block_table}" | awk -v snap_nmbr="${snap_nmbr}" '{print $snap_nmbr}'))

	# the snap_string_separators need to be flexible for handling date-based versioning from other sources
	if [[ ! -n "${snap_string_separator_2}" ]]; then
		snap_string_separator_2="_"
	elif [[ "${snap_string_separator_2}" == "empty" ]]; then
		unset snap_string_separator_2
	fi

	if [[ "${snap_identifier}" == "number" ]] || [[ ! -n "${snap_identifier}" ]]; then
		snap_identifier=${snap_nmbr};
	elif [[ "${snap_identifier}" == "frequency" ]]; then
		snap_identifier=${current_frequency}
	elif [[ "${snap_identifier}" == "empty" ]]; then
		unset snap_identifier; else
		echo "snap_identifier is not valid: ${snap_identifier}" && exit 1
	fi
	# get the names for the snapstring
	snap_name="${snap_label}""${snap_identifier}""${snap_string_separator_2}"
	snap_string="${snap_name}""${snap_date}"

	unset element block_config block_table supported_frequencies; else

	if [[ -n "${config_server}" ]]; then
		probe=$(echo "${config_server}" | grep "~" || true)
		if [[ -n "${probe}" ]]; then
			config_target=$(echo "${config_server}" | cut -d "~" -f 2)
			config_server=$(echo "${config_server}" | cut -d "~" -f 1)
		fi
	fi
fi

# translate mode to mode_create and mode_snapshot
if [[ -n "${mode}" ]]; then
	if [[ "${mode}" == "btrfs" ]] || [[ "${mode}" == "kvm" ]] || [[ "${mode}" == "lxd" ]] || [[ "${mode}" == "zfs" ]]; then
		mode_create=${mode}
		mode_snapshot=${mode}

	elif [[ "${mode}" == "directory" ]]; then
		mode_create=rsync
		mode_snapshot=file

	elif [[ "${mode}" == "mysql" ]] || [[ "${mode}" == "pgsql" ]]; then
		config_sql_server=localhost
		mode_create=pipe
		mode_snapshot=file

	elif [[ "${mode}" == "ldap" ]]; then
		mode_create=pipe
		mode_snapshot=file

	elif [[ "${mode}" == "file" ]]; then
		if [[ -n "${config_certificate}" ]]; then
			mode_create=pipe; else
			mode_create=rsync
		fi

		mode_snapshot=file

		else	echo "${mode} is not supported mode. Valid are: ${supported_mode}" && exit 1
	fi; else
	echo "no mode is set" && exit 1
fi

if [[ -n "${config_server}" ]]; then
	if [[ -n "${config_port}" ]]; then
		config_port=" -p ${config_port}"; else
		config_port=" -p 22"
	fi

	probe=$(ssh -O check -S ~/.ssh/%C  -p "${config_port}" "${config_server}" 2>&1 | grep 'No such file or directory')
	if [[ -n "${probe}" ]]; then
		# if not already exists, establish master connection for ssh. this will automatically close 1 minute after the script
		ssh -Nf -p "${config_port}" "${config_server}" -o ControlMaster=auto -o ControlPath=~/.ssh/%C -o ControlPersist=1m
	fi

	if  [[ ! -n "${config_target}" ]] || [[ ! "${mode_snapshot}" == "file" ]]; then
		config_target=server
	fi

	if [[ "${config_target}" == "server" ]]; then
		config_ssh_source_part1="ssh -S ~/.ssh/%C ${config_server}${config_port} \""
		config_ssh_source_part2="\""
		config_ssh_target_part1="ssh -S ~/.ssh/%C ${config_server}${config_port} \""
		config_ssh_target_part2="\""

	elif	[[ "${config_target}" == "local" ]]; then
		config_ssh_source_part1="ssh -S ~/.ssh/%C ${config_server}${config_port} \""
		config_ssh_source_part2="\""

		if [[ "${mode_create}" == "rsync" ]]; then
			ssh_rsync_source="-e \"ssh -S ~/.ssh/%C ${config_port}\" ${config_server}:"
		fi

	elif	[[ "${config_target}" == "remote" ]]; then
		config_ssh_target_part1="ssh -S ~/.ssh/%C ${config_server}${config_port} \""
		config_ssh_target_part2="\""

		if [[ "${mode_create}" == "rsync" ]]; then
			ssh_rsync_target="-e \"ssh -S ~/.ssh/%C ${config_port}\" ${config_server}:"
		fi

	elif	[[ "${config_target}" == "direct" ]]; then
		config_sql_server=${config_server}; else

		echo "something is wrong with the ssh settings" && exit 1
	fi
	unset config_target
fi

if [[ "${mode_create}" == "pipe" ]] && [[ -n "${config_certificate}" ]]; then
	# if config_certificate is a ssl certificate it is always a path. this way it is compatible with the current config file
	probe=$(echo ${config_certificate} | cut -c 1)
	if [[ "${probe}" == "/" ]] || [[ "${probe}" == "~" ]]; then
		snap_encrypt=" | openssl smime -encrypt -binary -text -aes256 -outform DER ${config_certificate}"; else
		snap_encrypt=" | gpg -r ${config_certificate} -e"
	fi
fi

if [[ "${mode_create}" == "pipe" ]] || [[ "${mode_create}" == "rsync" ]]; then
	#set back the control variable
	aa="-1"

	# files may have dot-sepparated file-types. It is convenient if this stays at the end.
	for root_set_element in "${root_set[@]}"
	do	aa=$((${aa} + 1))

		probe=$(echo ${snap_set[aa]} | rev | cut -c 1)
		if [[ "${probe}" == "/" ]]; then
			snap_file[aa]=$(echo "${root_set_element}" | rev | cut -d "/" -f 1 | rev | tr "~" " ")
			snap_set[aa]=$(echo "${snap_set[aa]}" | tr "~" " ") ; else
			snap_file[aa]=$(echo "${snap_set[aa]}" | rev | cut -d "/" -f 1 | rev | tr "~" " ")
			snap_set[aa]=$(echo "${snap_set[aa]}" | rev | cut -d "/" -f 2- | rev | tr "~" " ")/
		fi

		probe=$(echo "${snap_file[aa]}" | grep "\.")
		if [[ -n "${probe}" ]]; then
			snap_file_type[aa]=.$(echo "${snap_file[aa]}" | cut -d "." -f 2-)
			snap_file[aa]=$(echo "${snap_file[aa]}" | cut -d "." -f 1)
		fi
	done
fi

snap_string_offset=$((${#snap_string}))
if [[ "${mode_create}" == "zfs" ]] || [[ "${mode_create}" == "kvm" ]]; then
	snap_string_separator_1="@"
elif [[ ! -n "${snap_string_separator_1}" ]]; then
	snap_string_separator_1="_"
fi
snap_string_complete=${snap_string_separator_1}${snap_string}
#snap_name=${snap_string_separator_1}${snap_name}

# config_user has to be in the format user_id:group_id
if [[ -n "${config_user}" ]]; then
	probe=$(echo ${config_user} | grep ":" || true)
	if [[ ! -n "${probe}" ]]; then
		config_user="${config_user}:${config_user}"
	fi

	aa="-1"

	for root_set_element in "${root_set[@]}"
	do	aa=$((${aa} + 1))
		change_user[aa]=" && chown -R ${config_user} '${snap_set[aa]}''${snap_file[aa]}'${snap_string_complete}${snap_file_type[aa]}"
	done
fi

# internally mode_create is not different from file execpt an additional / so that rsync doesn't copy the directory inside the target but change the name to it
if [[ "${mode}" == "directory" ]]; then
	config_options_rsync2="/"
	mode=file
fi

#set back the control variable
aa="-1"

if [[ "${check_config}" == "set" ]]; then
	if [[ ! -n "${snap_set}" ]] || [[ -z "${snap_set}" ]]; then
		echo "Target is not set or empty" && exit 1
	fi

	if [[ ! -n "${root_set}" ]] || [[ -z "${root_set}" ]] && [[ ! "${mode_create}" == "zfs" ]]; then
		echo "Source is not set or empty" && exit 1
	fi

	echo "mode is: ${mode_create} and the frequency is: ${current_frequency}"
	echo "label, frequency and date is: ${snap_string} with the length: ${snap_string_offset}"
	echo "the sourceserver is: ${config_server}. Valid is an ip, a dns or empty"
	echo "Target, Snapshotnumer and Source are:"

	for snap_set_element in "${snap_set[@]}"
	do	aa=$((${aa} + 1))
		echo "${snap_set[aa]}${snap_file[aa]}${snap_string_complete}${snap_file_type[aa]} ${snap_limit[aa]} ${root_set[aa]}"
	done
	aa="-1"

	if [[ "${mode_create}" == "rsync" ]] || [[ "${mode_create}" == "pipe" ]]; then
		echo "user:group is: ${config_user}"
		echo "the path to the certificate is: ${config_certificate}"
		echo "the target for the snapshot is: ${config_target}. Valid is local, remote and empty"
	fi

	if [[ "${mode_create}" == "mysql" ]]; then
		echo "the path to the credentials is: ${config_credentials}"
	fi

	if [[ ! "${check_commands}" == "set" ]]; then
		exit 0
	fi
fi

# snap_number has n-elements but the script starts with element 0. So the script has to count to n-1
if [ -n "${snap_set}" ] && [ ! -z "${snap_set}" ]
	then	snap_set_number=$((${#snap_set[@]} -1))
fi

while [[ "${snap_set_number}" -gt "${aa}" ]]
do	aa=$((${aa} + 1))
	# if snap_set and root_set contained spaces they had been translated to "~" and have to be retranslated to " "
	snap_set[aa]=$(echo "${snap_set[aa]}" | tr "~" " ")
	root_set[aa]=$(echo "${root_set[aa]}" | tr "~" " ")

	if [[ ! -z "${snap_limit[aa]}" ]] && [[ ! "${snap_limit[aa]}" == "0" ]]; then
		if [[ "${check_commands}" == "set" ]]; then
			printf -- "\n--------------- ${snap_set[aa]}${snap_file[aa]}${snap_string_complete}${snap_file_type[aa]} ---------------\n"
		fi

		if [[ "${check_previous}" == "set" ]]; then
			if [[ "${mode_snapshot}" == "btrfs" ]] || [[ "${mode_snapshot}" == "file" ]]; then
				if [[ -n "${config_ssh_source_part1}" ]]; then
					probe=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "find "${snap_set[aa]}""${snap_file[aa]}"${snap_string_complete}${snap_file_type[aa]} -maxdepth 0 2> /dev/null"); else
					probe=$(find "${snap_set[aa]}""${snap_file[aa]}"${snap_string_complete}${snap_file_type[aa]} -maxdepth 0 2> /dev/null)
				fi

			elif [[ "${mode_snapshot}" == "zfs" ]]; then
				if [[ -n "${config_ssh_source_part1}" ]]; then
					probe=$(ssh -S ~/.ssh/%C ${config_server}${config_port} "zfs get -Ho value -r name '${root_set[aa]}'" | tail -n +2 | grep "${root_set[aa]}"${snap_string_complete}); else
					probe=$(zfs get -Ho value -r name "${root_set[aa]}" | tail -n +2 | grep "${root_set[aa]}"${snap_string_complete})
				fi

			elif [[ "${mode_snapshot}" == "lxd" ]]; then
				if [[ -n "${config_ssh_source_part1}" ]]; then
					probe=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "lxc info '${root_set[aa]}'" | sed -e '1,/^Snapshots:/d' | awk ' { print $1 } ' | grep '${root_set[aa]}'${snap_string_complete} 2> /dev/null); else
					probe=$(lxc info "${root_set[aa]}" | sed -e '1,/^Snapshots:/d' | awk ' { print $1 } ' | grep '${root_set[aa]}'${snap_string_complete} 2> /dev/null)
				fi

			elif [[ "${mode_snapshot}" == "kvm" ]]; then
				if [[ -n "${config_ssh_source_part1}" ]]; then
					probe=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "qm listsnapshot '${root_set[aa]}' | grep ${snap_string} 2> /dev/null"); else
					probe=$(qm listsnapshot "${root_set[aa]}" | grep ${snap_string} 2> /dev/null)
				fi
			fi

			# if snapshot already exists the snapshot will be omitted
			if [[ -n "${probe}" ]]; then
				previous=exists
			fi
		fi

		if [[ ! "${previous}" == "exists" ]]; then
			if [[ "${mode_create}" == "zfs" ]]; then
				command="${config_ssh_source_part1}zfs snapshot '${root_set[aa]}'${snap_string_complete}${config_ssh_source_part2}"

			elif [[ "${mode_create}" == "btrfs" ]]; then
				command="${config_ssh_source_part1}btrfs subvolume snapshot -r '${root_set[aa]}' '${snap_set[aa]}'${snap_string_complete}${config_ssh_source_part2}"

			elif [[ "${mode_create}" == "pipe" ]]; then
				if [[ "${mode}" == "file" ]]; then
					command_part1="cat '${root_set[aa]}'${snap_encrypt}"
				elif [[ "${mode}" == "mysql" ]]; then
					command_part1="mysqldump --defaults-extra-file=${config_credentials} --routines --triggers --single-transaction -h ${config_sql_server} '${snap_file[aa]}'${snap_encrypt}"
				elif [[ "${mode}" == "pgsql" ]]; then
					command_part1="pg_dump -h ${config_sql_server} -U ${config_credentials} -C -F c '${snap_file[aa]}'${snap_encrypt}"
				elif [[ "${mode}" == "ldap" ]]; then
					command_part1="slapcat -n '${root_set[aa]}'${snap_encrypt}"
				fi

				command_part2="cat > '${snap_set[aa]}''${snap_file[aa]}'${snap_string_complete}${snap_file_type[aa]}${change_user[aa]}"
				command="${config_ssh_source_part1}${command_part1}${config_ssh_source_part2} | ${config_ssh_target_part1}${command_part2}${config_ssh_target_part2}"

			elif [[ "${mode_create}" == "rsync" ]]; then
				if [[ -n "${ssh_rsync_source}" ]] || [[ -n "${ssh_rsync_target}" ]]; then
					command="rsync ${config_options_rsync} ${ssh_rsync_source}'${root_set[aa]}'${config_options_rsync2} ${ssh_rsync_target}'${snap_set[aa]}''${snap_file[aa]}'${snap_string_complete}${snap_file_type[aa]}${change_user[aa]}"; else
					command="${config_ssh_source_part1}rsync ${config_options_rsync} '${root_set[aa]}'${config_options_rsync2} '${snap_set[aa]}''${snap_file[aa]}'${snap_string_complete}${snap_file_type[aa]}${change_user[aa]}${config_ssh_source_part2}"
				fi

			elif [[ "${mode_create}" == "lxd" ]]; then
				command="${config_ssh_source_part1}lxc snapshot '${root_set[aa]}' '${root_set[aa]}'${snap_string_complete}${config_ssh_source_part2}"

			elif [[ "${mode_create}" == "kvm" ]]; then
				command="${config_ssh_source_part1}qm snapshot '${root_set[aa]}' ${snap_string}${config_ssh_source_part2}"
			fi

			# If snapshots not created by this script should be handled, existing_only can be set
			if [[ ! -n "${snap_new_impede}" ]]; then
				if [[ "${check_commands}" == "set" ]]; then
					echo "${command}"; else
					eval ${command}
				fi
			fi

			if [[ "${config_function}" == "list" ]]; then
				# determining the snapshots and their number
				if [[ "${mode_snapshot}" == "zfs" ]]; then
					if [[ -n "${config_ssh_target_part1}" ]]; then
						snap_shots_strict=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "zfs get -Ho value -r name '${root_set[aa]}'" | tail -n +2 | grep ${root_set[aa]}${snap_string_separator_1}${snap_name}); else
						snap_shots_strict=$(zfs get -Ho value -r name "${root_set[aa]}" | tail -n +2 | grep "${root_set[aa]}"${snap_string_separator_1}${snap_name})
					fi

				elif [[ "${mode_snapshot}" == "btrfs" ]] || [[ "${mode_snapshot}" == "file" ]]; then
					if [[ -n "${config_ssh_target_part1}" ]]; then
						snap_shots_strict=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "find '${snap_set[aa]}''${snap_file[aa]}'${snap_string_separator_1}${snap_name}* -maxdepth 0 2> /dev/null"); else
						snap_shots_strict=$(find "${snap_set[aa]}""${snap_file[aa]}"${snap_string_separator_1}${snap_name}* -maxdepth 0 2> /dev/null)
					fi

				elif [[ "${mode_snapshot}" == "lxd" ]]; then
					if [[ -n "${config_ssh_target_part1}" ]]; then
						snap_shots_strict=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "lxc info '${root_set[aa]}' | sed -e '1,/^Snapshots:/d' | awk ' { print $1 } ' 2> /dev/null"); else
						snap_shots_strict=$(lxc info "${root_set[aa]}" | sed -e '1,/^Snapshots:/d' | awk ' { print $1 } ' 2> /dev/null)
					fi

				elif [[ "${mode_snapshot}" == "kvm" ]]; then
					if [[ -n "${config_ssh_target_part1}" ]]; then
						snap_shots_strict=$(ssh -S ~/.ssh/%C ${config_server}${config_port}  "qm listsnapshot '${root_set[aa]}' | awk '{print $1}' | grep ${snap_name} 2> /dev/null"); else
						snap_shots_strict=$(qm listsnapshot "${root_set[aa]}" | awk '{print $1}' | grep ${snap_name} 2> /dev/null)
					fi
				fi

				if [[ -n "${add_snapshot}" ]] && [[ ! -n "${snap_new_impede}" ]]; then
					snap_shots_strict=${snap_shots_strict}$'\n'"${snap_set[aa]}""${snap_file[aa]}"${snap_string_complete}${snap_file_type[aa]}
				fi
				snap_number_strict=$(echo "${snap_shots_strict}" | awk 'END{print NR}')

				if [[ "${check_snapshots}" == "set" ]]; then
					printf "The Snapshotnumber is ${snap_number_strict}:\n${snap_shots_strict}\n"
				fi

				while [[ "${snap_number_strict}" -gt "${snap_limit[aa]}" ]] && [[ ! -n "${check_snapshots}" ]]
				do	snap_del=$(echo "${snap_shots_strict}" | awk 'NR==1{print $0}')

					if [[ "${mode_create}" == "kvm" ]]; then
						command="${config_ssh_target_part1}qm delsnapshot '${root_set[aa]}' ${snap_del}${config_ssh_target_part2}"

					elif [[ "${mode_create}" == "zfs" ]]; then
						command="${config_ssh_target_part1}zfs destroy '${snap_del}'${config_ssh_target_part2}"

					elif [[ "${mode_create}" == "btrfs" ]]; then
						command="${config_ssh_target_part1}btrfs subvolume delete '${snap_del}'${config_ssh_target_part2}"

					elif [[ "${mode_create}" == "rsync" ]] || [[ "${mode_create}" == "pipe" ]]; then
						command="${config_ssh_target_part1}rm -rf '${snap_del}'${config_ssh_target_part2}"

					elif [[ "${mode_create}" == "lxd" ]]; then
						command="${config_ssh_target_part1}lxc delete '${snap_set[aa]}'/'${snap_del}'${config_ssh_target_part2}"
					fi

					snap_shots_strict=$(echo "${snap_shots_strict}" | tail -n +2)
					snap_number_strict=$((${snap_number_strict} - 1))

					if [[ "${check_commands}" == "set" ]]; then
						echo "${command}"; else
						eval ${command}
					fi
				done
			fi
		fi
	fi
done
